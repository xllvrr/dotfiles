% !TeX encoding = ISO-8859-1
% Ceci est la documentation du package "scratch3"
%
% Fichier compilé avec pdflatex
\documentclass[french,a4paper,10pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=2cm]{geometry}
\usepackage[bottom]{footmisc}
\usepackage{libertine,boites,tikz,enumitem,MnSymbol,babel,xspace,listings,scratch3}
\usepackage[scaled=0.8]{luximono}
\frenchbsetup{og=«,fg=»}
\def\SCRATCH{\texttt{scratch}\xspace}
\def\SSCRATCH{\texttt{\scrname}\xspace}
\makeatletter
\def\code{\expandafter\code@i\string}
\def\code@i#1{%
	\begingroup
		\par\nobreak\medskip\parindent0pt
		\leftskip.1\linewidth
		\catcode`\^^I 13 \begingroup\lccode`\~`\^^I \lowercase{\endgroup\def~{\leavevmode\space\space\space\space}}%
		\let\do\@makeother \dospecials
		\ttfamily\small\@noligs
		\make@car@active\<{$\langle$\begingroup\itshape}%
		\make@car@active\>{\endgroup$\rangle$}%
		\obeylines\obeyspaces
		\def\code@ii##1#1{##1\par\medbreak\endgroup}%
		\code@ii
}
\long\def\grab@toks#1\relax{\gdef\right@content{#1}}

\newcommand\disable@lig[1]{%
	\catcode`#1\active
	\begingroup
		\lccode`\~`#1\relax
		\lowercase{\endgroup\def~{\leavevmode\kern\z@\string#1}}%
}

\newcommand\make@car@active[1]{%
	\catcode`#1\active
	\begingroup
		\lccode`\~`#1\relax
		\lowercase{\endgroup\def~}%
}

\newcommand\exemple{%
	\begingroup
	\parskip\z@
	\exemple@}

\newcommand\exemple@{%
	\medbreak\noindent
	\begingroup
		\let\do\@makeother\dospecials
		\make@car@active\ { {}}%
		\make@car@active\^^M{\par\leavevmode}%
		\make@car@active\^^I{\space\space}%
		\make@car@active\,{\leavevmode\kern\z@\string,}%
		\make@car@active\-{\leavevmode\kern\z@\string-}%
		\make@car@active\>{\leavevmode\kern\z@\string>}%
		\make@car@active\<{\leavevmode\kern\z@\string<}%
		\@makeother\;\@makeother\!\@makeother\?\@makeother\:% neutralise frenchb
		\exemple@@
}

\newcommand\exemple@@[1]{%
	\def\@tempa##1#1{\exemple@@@{##1}}%
	\@tempa
}

\newcommand\exemple@@@[1]{%
	\xdef\the@code{#1}%
	\endgroup
		\begingroup
			\fboxrule0.4pt \fboxsep=5pt
			\let\breakboxparindent\z@
			\def\bkvz@top{\hrule\@height\fboxrule}%
			\def\bkvz@bottom{\hrule\@height\fboxrule}%
			\let\bkvz@before@breakbox\relax
			\def\bkvz@set@linewidth{\advance\linewidth\dimexpr-2\fboxrule-2\fboxsep\relax}%
			\def\bkvz@left{\vrule\@width\fboxrule\kern\fboxsep}%
			\def\bkvz@right{\kern\fboxsep\vrule\@width\fboxrule}%
			\breakbox
				\kern.5ex\relax
				\begingroup
					\ttfamily\small\the@code\par
				\endgroup
				\kern3pt
				\hrule height0.1pt width\linewidth depth0.1pt
				\vskip5pt
				\newlinechar`\^^M\everyeof{\noexpand}\scantokens{#1}\par
			\endbreakbox
		\endgroup
	\medbreak
	\endgroup
}
\begingroup
	\catcode`\<13 \catcode`\>13
	\gdef\verb{\relax\ifmmode\hbox\else\leavevmode\null\fi
		\bgroup
			\verb@eol@error \let\do\@makeother \dospecials
			\verbatim@font\@noligs
			\catcode`\<13 \catcode`\>13 \def<{\begingroup$\langle$\itshape}\def>{\/$\rangle$\endgroup}%
			\@ifstar\@sverb\@verb}
\endgroup
\def\longfrscrdate@i#1/#2/#3\@nil{\number#3\relax\ifnum\number#3=1 \noexpand\ier\fi\space \ifcase#2 \or janvier\or février\or mars\or avril\or mai\or juin\or juillet\or aout\or septembre\or octobre\or novembre\or décembre\fi\space#1}
\edef\longfrscrdate{\expandafter\longfrscrdate@i\scrdate\@nil}
\makeatother
\begingroup
	\catcode`\_11 
	\gdef\cleval#1#2{%
		\bigbreak\noindent
		\hbox to .25\linewidth{%
			\color{teal}\bfseries\ttfamily
			\detokenize{#1}=$\langle$\detokenize{#2}$\rangle$\hss}\kern2.5em 
		(\textit{Défaut} : {\color{teal}\ttfamily
		\skv_eearg\skv_ifempty{\useKV[\scrname]{#1}}
			{\detokenize{{}}}
			{\detokenize\expandafter\expandafter\expandafter{\useKV[\scrname]{#1}}}}\unskip)%
		\par\nobreak
	}
\endgroup
\def\suffixe#1{\begingroup\sffamily\bfseries\color{scr#1}#1\endgroup}
\newenvironment{version}[2]
	{%
		\paragraph{\hbox to 4em {v\hskip1pt #1\hfill}#2}\hskip0pt \par
		\catcode`\>13 \begingroup\lccode`\~`\> \lowercase{\endgroup\let~}\item
		\begin{itemize}%
	}
	{%
		\end{itemize}%
	}
\begin{document}
\parindent=0pt
\thispagestyle{empty}
\begin{titlepage}
	\begingroup
		\centering
		\null\vskip.25\vsize
		{\large\bfseries L'extension pour \LaTeX\medbreak
		\Huge \begin{scratch}[line width=1.5pt]\blockmove\scrname\end{scratch}\par}
		\bigbreak
		v \scrver
		\smallbreak
		\longfrscrdate
		\vskip1.5cm
		Christian \bsc{Tellechea}\par
		\texttt{unbonpetit@netc.fr}\par
	\endgroup
	\vskip2cm
	\leftskip=.2\linewidth \rightskip=.2\linewidth \small
	Cette extension permet de dessiner des empilements de blocs similaires à ceux que l'on trouve dans le logiciel de programmation \emph{visuelle} « \SCRATCH v3\footnote{Le logiciel que l'on peut utiliser en ligne à \texttt{https://scratch.mit.edu/}} ».
\end{titlepage}
\parindent0pt
\section{Avant propos}
La présente extension intitulée \SSCRATCH, est une évolution de l'extension \SCRATCH qui imitait la version 2 du logiciel. Depuis janvier~2019, le logiciel est passé à la version~3 et l'extension \SCRATCH est donc devenue obsolète et non maintenue.\medbreak

Cette version de \SSCRATCH étant la première, elle est susceptible d'être immature, c'est-à-dire de contenir des bugs, des incohérences ou des effets non désirés. Si cela se produit, je remercie les utilisateurs de bien vouloir me le faire savoir par email ou \emph{via} le « bugtracker » de \texttt{gitlab} à l'adresse \begin{center}
\texttt{\detokenize{https://framagit.org/unbonpetit/scratch3/issues}}
\end{center}

Les utilisateurs les plus attentifs auront sans doute remarqué que seuls les blocs de type «stylo» sont disponibles parmi ceux qui sont dorénavant considérés comme «extension». Il s'agit, pour l'instant, d'un choix délibéré...

\paragraph{Attention} Il est fortement déconseillé de charger les packages \SCRATCH et \SSCRATCH en raison de plusieurs définitions communes qu'ils partagent et qui conduiraient inévitablement à des dysfonctionnements. L'erreur qui survient ---~et le refus de charger le deuxième~--- lorsqu'on tente de charger ces deux packages ne doivent pas être désactivés par une modification de leurs codes.\medbreak

L'extension \SSCRATCH requiert les extensions \texttt{simplekv} et \texttt{ti\textit kz} qui sont automatiquement chargées si cela s'avère nécessaire.\medbreak

Fidèle à mes convictions, la documentation de cette extension n'est disponible qu'en français.

\section{L'environnement \SCRATCH}
Pour dessiner un programme comme le fait \SCRATCH, il faut ouvrir un environnement «\SCRATCH» et écrire dans cet environnement les macros correspondant aux \emph{blocs} que l'on veut y mettre :

\code|\begin{scratch}
	macros pour dessiner des blocs
\end{scratch}|

Comme le savent ceux qui enseignent l'algorithmique et la programmation avec le très-à-la-mode\footnote{Je ne déteste rien de plus comme langage de programmation que ce \emph{truc} vaguement graphique, ultra limité et contre-productif dans l'apprentissage du codage qu'est \SCRATCH et que l'éducation nationale veut à tout prix imposer. Je ne compte bien évidemment pas me plier à ce nouveau dogme ridicule et ne l'utiliserai ni ne l'enseignerai; je considère que les élèves méritent mieux que \SCRATCH --~ADA, java ou lua par exemple~-- comme entrée dans le monde de la programmation.} logiciel « \SCRATCH », les programmes sont construits avec des briques, appelés «blocs», qui peuvent s'emboiter les uns sur les autres. Ces blocs sont de plusieurs couleurs, chacune correspondant à un type d'instruction que l'on retrouve dans les menus de \SCRATCH.

J'ai pris le parti d'écrire des macros ayant comme argument le texte qui figure dans le bloc. Ce faisant, on a plus de liberté que dans \SCRATCH où les blocs ont des textes prédéfinis, mais cette liberté permet d'utiliser cette extension quelle que soit la langue dans laquelle on écrit.

Enfin, j'ai cherché le bon compromis entre complexité du code et qualité des dessins obtenus avec cette extension: ils \emph{ressemblent} à ceux du logiciel \SCRATCH, mais le but de cette extension n'est \emph{pas} la ressemblance absolue au pixel près!

\section{Les blocs normaux}
Ces blocs sont les plus courants et possèdent une encoche d'emboitement, femelle en haut et mâle en bas. Les macros permettant de dessiner ces blocs ont des noms de la forme \verb|\block<suffixe>| et ont un seul argument obligatoire qui est le texte que l'on souhaite mettre dans le bloc. Par exemple, un bloc bleu (correspondant au menu «mouvement») a un suffixe \suffixe{move}, et est dessiné grâce à la macro \verb|\blockmove{<texte>}|. Ainsi, dans l'environnement \SCRATCH, écrire \verb|\blockmove{Bonjour le monde}| donne
\begin{center}\begin{scratch}\blockmove{Bonjour le monde}\end{scratch}\end{center}

La police d'écriture dans chaque bloc est la police « \textsf{sans serif} » qui est définie dans le document au moment où l'environnement est appelé : pratiquement, cela signifie que la macro \verb|\sffamily| est exécutée avant que le texte des blocs ne soit composé. La clé «\texttt{pre text}» (voir page~\pageref{pre text}), modifiable par l'utilisateur, contient par défaut le code exécuté avant que du texte ne soit affiché, c'est-à-dire \verb|\sffamily|. Dans cette documentation, la police sans serif est «\textsf{biolinum}».

La plupart des dimensions des blocs sont proportionnelles à la taille de la police en cours. On peut donc jouer sur la taille de la police (via les classiques macros \verb|\small|, \verb|\large|, \verb|\footnotesize|, etc) pour modifier la taille des blocs\footnote{Il y a aussi la clé «\texttt{scale}» pour mettre le dessin à l'échelle que l'on souhaite, voir page~\pageref{cle-scale}} .

Voici un inventaire des tous les blocs disponibles, empilés les uns sous les autres :

\exemple/Voici un algorithme bizarre : \begin{scratch}
	\blockmove{bloc de mouvement}
	\blocklook{bloc d'apparence}
	\blocksound{bloc de son}
	\blockpen{bloc de stylo}
	\blockvariable{bloc de variable}
	\blocklist{bloc de liste}
	\blockevent{bloc d'événement}
	\blockcontrol{bloc de contrôle}
	\blocksensing{bloc de capteur}
\end{scratch}/

Il faut donc retenir cette logique : les suffixes \suffixe{move}, \suffixe{look}, \suffixe{sound}, \suffixe{pen}, \suffixe{variable}, \suffixe{list}, \suffixe{event}, \suffixe{control} et \suffixe{sensing} correspondent aux couleurs des blocs. Il existe aussi le suffixe \suffixe{operator} qui n'a pas été montré précédemment puisqu'aucun bloc n'existe pour la fonction «opérateurs».

\section{Les ovales}
Les « ovales » sont, selon le code graphique de \SCRATCH, censés contenir des variables que l'utilisateur spécifie lui-même (comme des nombres ou du texte) :
\begin{center}
	\begin{scratch}
		\blockmove{tourner de \turnleft{} de \ovalnum{45} degrés}
		\blocklook{penser à \ovalnum{Hmm..} pendant \ovalnum{2} secondes}
	\end{scratch}
\end{center}
Les variables peuvent être prédéfinies dans \SCRATCH ou créées par l'utilisateur et dans ce cas, les ovales sont de couleur identique à la couleur du thème auquel appartient la variable:
\begin{center}
	\begin{scratch}
		\blocklook{penser à \ovalsensing{réponse}}
		\blockmove{aller à x: \ovaloperator{\ovalmove{ abscisse x} + \ovalnum{1}} y: \ovalmove{ordonnée y}}
	\end{scratch}
\end{center}
Ces variables peuvent également être spécifiques aux blocs concernés, sélectionnées parmi plusieurs possibilités, auquel cas l'ovale est de couleur plus sombre que le bloc et se termine avec une flèche de sélection :
\begin{center}
	\begin{scratch}
		\blocksound{jouer le son \ovalsound*{Meow}}
		\blockcontrol{créer un clone de \ovalcontrol*{moi même}}
	\end{scratch}
\end{center}
Au niveau des macros utilisées :
\begin{itemize}
	\item la macro \verb|\ovalnum{<nombre>}| dessine un ovale à fond blanc;
	\item la macro \verb|\oval<suffixe>| trace un ovale de la couleur de  \verb|<suffixe>|;
	\item en version étoilée, \verb|\oval<suffixe>*| trace un ovale de couleur plus sombre avec une flèche de sélection;
	\item les macros \verb|\turnleft| et \verb|\turnright| dessinent des flèches de rotation dans les blocs \verb|\blockmove|.
\end{itemize}

\exemple/Ovales de toutes sortes : \begin{scratch}
		\blockmove{tourner de \turnleft{} de \ovalnum{45} degrés}
		\blocklook{penser à \ovalnum{Hmm..} pendant \ovalnum{2} secondes}
		\blocklook{penser à \ovalsensing{réponse}}
		\blockmove{aller à x: \ovaloperator{\ovalmove{ abscisse x} + \ovalnum{1}} y: \ovalmove{ordonnée y}}
		\blocksound{jouer le son \ovalsound*{Meow}}
		\blockcontrol{créer un clone de \ovalcontrol*{moi même}}
\end{scratch}/

Toutes les macros de la forme \verb|\oval<suffixe>| sont utilisables \emph{en dehors} de l'environnement \SCRATCH:

\exemple/Voici une variable simple «\ovalmove{direction}»,
une variable sélectionnée «\ovalsound*{Meow}»./

Il faut signaler que les blocs de suffixes \suffixe{operator}, \suffixe{variable} , \suffixe{list} ou \suffixe{moreblocks} ne peuvent avoir d'ovales de sélection. N'ayant pas de sens pour \SCRATCH, une erreur sera émise si une macro étoilée \verb|\oval<suffixe>*| est utilisée, et visuellement, cela se traduira par une couleur de remplissage du bloc en rouge.
\medbreak
Un ovale rempli de couleur et accessible avec la macro \verb|\pencolor{<couleur>}| permet de sélectionner la couleur du stylo:

\exemple/\begin{scratch}
	\blockpen{stylo en position d'écriture}
	\blockpen{mettre la couleur du style à \pencolor{red!75!black}}
	\blockmove{avancer de \ovalnum{25}}
\end{scratch}/

\section{Les blocs de début}
Ces blocs sont de la couleur \suffixe{event} pour la plupart (macro \verb|\blockinit|), mais il existe aussi un bloc de début de couleur \suffixe{control} (macro \verb|\blockinitclone|). Le drapeau vert est dessiné avec la macro \verb|\greenflag|.

\exemple/Voici un début :
\begin{scratch}
	\blockinit{quand \greenflag est cliqué}
	\blockmove{suite de l'algorithme...}
\end{scratch}
et un autre :
\begin{scratch}
	\blockinitclone{quand je commence comme un clone}
	\blocklook{enfiler le costume de clown !}
\end{scratch}/

\section{Les rectangles}
Un menu déroulant contenant des valeurs prédéfinies est symbolisé par un rectangle dont la couleur reprend celle du bloc dans lequel il se trouve. Pour ce faire, la macro \verb|\selectmenu{<texte>}| doit être exécutée :

\exemple/\begin{scratch}
	\blockinit{Quand je reçois \selectmenu{message 1}}
	\blocksound{ajouter \ovalnum{10} à l'effet \selectmenu{hauteur}}
	\blocklook{mettre l'effet \selectmenu{couleur} à \ovalnum{0}}
	\blockvariable{mettre \selectmenu{ma_variable} à \ovalnum{10}}
\end{scratch}/

\section{Les losanges et les blocs de test}
Dans la symbolique graphique de \SCRATCH, les losanges contiennent des valeurs booléennes ayant vocation à se retrouver dans un bloc de test. Pour dessiner de tels objets booléens, les macros \verb|\bool<suffixe>{<texte>}| sont utilisées où les \verb|<suffixes>| représentent les couleurs correspondant à la fonction du booléen tracé : \suffixe{list}, \suffixe{sensing} ou \suffixe{operator}.

Les blocs de test sont de deux types,selon qu'ils possèdent ou pas une branche « else».
\code|\blockif{<texte du test>}
	{<instructions si test vrai>}|
et
\code|\blockifelse{<texte du test>}
	{<instructions si test vrai>}
	{<instructions si test faux>}|


\exemple/Conditions : \begin{scratch}
	\blockif{si \booloperator{\ovalmove{abscisse x} < \ovalnum{7}} alors}
		{\blockmove{aller à \selectmenu{position aléatoire}}
		 \blocklook{basculer sur costume \selectmenu{costume 4}}
		}
	\blockmove{aller à \selectmenu{pointeur souris}}
\end{scratch}
et
\begin{scratch}
	\blockifelse{si \boolsensing{couleur \pencolor{blue!65} touchée ?} alors}
		{\blockmove{avancer de \ovalnum{2}}
		\blocksound{jouer le son \selectmenu{miaou}}
		}
		{\blockvariable{mettre \ovalvariable{total} à \ovaloperator{\ovalvariable{total} + \ovalnum{1}}}
		\blocksound{arrêter tous les sons}
		}
	\blockmove{aller à \selectmenu{pointeur souris}}
\end{scratch}/

La macros \verb|\pencolor| et celles de la forme \verb|\bool<suffixe>| sont utilisables \emph{en dehors} d'un environnement \SCRATCH :

\exemple/Une couleur : \pencolor{cyan}.\par
Un booléen : \boollist{liste \selectmenu{malist} contient \ovalnum{foobar}}.\par
Un autre : \booloperator{\booloperator{\ovalvariable{varx} > \ovalnum{1}}
et \booloperator{\ovalvariable{varx} < \ovalnum{5}}}./

La macro \verb|\boolempty[<dimension>]| permet de tracer un losange vide. L'argument optionnel est une \verb|<dimension>| qui vaut \verb|2em| par défaut.

\exemple/\begin{scratch}
	\blockifelse{si \boolempty[3em] alors}
		{\blocklook{dire \ovalnum{le test est vrai}}}
		{\blocklook{dire \ovalnum{le test est faux}}}
\end{scratch}/

\section{Les blocs de fin}
Ces blocs sont susceptibles de clore un algorithme et n'ont donc pas d'encoche mâle dans leur partie basse. Ils ne peuvent être que du type \suffixe{control} et sont dessinés avec la macro \verb|\blockstop{<texte>}|

\exemple/\begin{scratch}\blockstop{supprimer ce clone}\end{scratch}
ou
\begin{scratch}\blockstop{stop \selectmenu{ce script}}\end{scratch}/

\section{Les blocs de répétition}
Ces blocs sont de deux types, selon que la répétition est prévue pour s'arrêter ou pas (boucle infinie). Ils seront dessinés par les macros \verb|\blockrepeat| et \verb|\blocinfloop| ayant chacune \emph{deux} arguments : le premier étant le \verb|<texte>| du bloc et le second la suite d'instructions à répéter.

\exemple/\begin{scratch}
	\blockpen{stylo en position d'écriture}
	\blockrepeat{répéter \ovalnum{4} fois}
		{
		\blockmove{avancer de \ovalnum{10}}
		\blockmove{tourner \turnright{} de \ovalnum{90} degrés}
		}
\end{scratch}
et
\begin{scratch}
	\blockpen{stylo en position d'écriture}
	\blockinfloop{répéter indéfiniment}
		{
		\blockmove{s'orienter à \ovaloperator{nombre aléatoire entre \ovalnum{0} et \ovalnum{359}}}
		\blockmove{avancer de \ovaloperator{nombre aléatoire entre \ovalnum{1} et \ovalnum{10}}}
		\blockif{si \boolsensing{\selectmenu{bord} touché?}}
			{
			\blockmove{aller à x: \ovalnum{0} y: \ovalnum{0}}
			}
		}
\end{scratch}/

\section{Les blocs de définition}
Les « procédures », ayant le suffixe \suffixe{moreblocks}, permettent d'étendre les maigres possibilités données au programmeur en \SCRATCH.

\exemple/\begin{scratch}
	\initmoreblocks{définir \namemoreblocks{trace_carré \ovalmoreblocks{coté_carré}}}
	\blockrepeat{répéter \ovalnum4 fois}
		{\blockmove{avancer de \ovalmoreblocks{coté_carré}}
		\blockmove{tourner \turnleft{} de \ovalnum{90} degrés}
		}
\end{scratch}
puis
\begin{scratch}
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blockpen{relever le stylo}
	\blockmove{aller à x: \ovalnum0 y: \ovalnum0}
	\blockmove{s'orienter à \ovalnum{90} degrés}
	\blockpen{stylo en position d'écriture}
	\blockrepeat{répéter \ovalnum{10} fois}
		{
		\blockmoreblocks{trace carré \ovalnum{50}}
		\blockmove{avancer de \ovalnum{10}}
		\blockmove{tourner \turnleft{} de \ovalnum{36} degrés}
		}
\end{scratch}/

À l'intérieur d'un \verb|\namemoreblocks|, on peut mettre \verb|\ovalmoreblocks| pour spécifier un argument de type nombre ou texte ou bien \verb|\boolmoreblocks| pour un argument de type booléen.

\section{Bloc invisible}
Bien que ce genre de bloc n'existe pas avec \SCRATCH, cette fonctionnalité peut s'avérer utile. On insère un espace vide avec \verb|\blockspace[<coeff>]|. L'espace verticale insérée est égale à la hauteur normale d'un bloc multipliée par le \verb|<coeff>|, valeur optionnelle qui vaut 1 par défaut.

\exemple/\begin{scratch}
	\blockmove{ci-dessous, une espace d'un bloc}
	\blockspace
	\blockmove{ci dessous, une espace égale à la moitié d'un bloc}
	\blockspace[0.5]
	\blockmove{la suite}
\end{scratch}/

\section{Personnalisation}
Plusieurs \verb|<paramètres>| peuvent être réglés par l'utilisateur selon la syntaxe \verb|<clé>=<valeur>|. Cas paramètres peuvent être spécifiés dans :

\begin{itemize}
	\item l'argument optionnel de l'environnement \verb|\begin{scratch}[<paramètres>]| auquel cas les \verb|<paramètres>| ne s'appliquent qu'à cet environnement;
	\item l'argument de la macro \verb|\setscratch{<paramètres>}| pour spécifier des \verb|<paramètres>| pour les environnements \SCRATCH à venir;
	\item l'argument de \verb|\setdefaultscratch{<paramètres>}| pour spécifier des \verb|<paramètres>| \emph{par défaut}.
\end{itemize}

Il existe la macro \verb|\resetscratch| qui remet à leur valeur par défaut tous les \verb|<paramètres>| de \SCRATCH, pour annuler les effets d'une macro \verb|\setscratch|.\bigbreak

Voici les \verb|<paramètres>| disponibles :

\cleval{else word}{caractères}
Représente est le mot qui est inséré dans la branche « else » d'un bloc de test.

\cleval{pre text}{code}\label{pre text}
C'est le \verb|code| qui est exécuté avent que du texte ne soit affiché par \SSCRATCH.

\cleval{x sep}{dimension}
Représente l'espace horizontale insérée entre les bords droit et gauche du texte du bloc et les bords droits et gauche du bloc. La valeur est ramenée si nécessaire dans l'intervalle [3pt ; 1em].

\cleval{y sepsup}{dimension}
Représente l'espace verticale insérée entre le bas de l'encoche femelle et le bord supérieur du texte du bloc. La valeur est ramenée si nécessaire dans l'intervalle [3pt ; 3ex].

\cleval{y sepinf}{dimension}
Représente l'espace verticale insérée entre le bas du bloc et le bord inférieur du texte du bloc. La valeur est ramenée si nécessaire dans l'intervalle [3pt ; 3ex].

\cleval{line width}{dimension}
Représente l'épaisseur des lignes de relief des blocs et le double des lignes de relief des losanges booléens. La valeur est ramenée si nécessaire dans l'intervalle [0pt ; 5pt].

\cleval{loop width}{dimension}
Représente est la largeur de la barre verticale des blocs de répétition ou de test. La valeur est ramenée si nécessaire dans l'intervalle [3pt ; 3em].

\cleval{loop height}{dimension}
Représente est l'épaisseur des barres horizontales « else » et inférieure des blocs de répétition ou de test. La valeur est ramenée si nécessaire dans l'intervalle [3pt ; 3ex].

\cleval{corner}{dimension}
Représente la dimension des chanfreins des blocs. La valeur est ramenée si nécessaire dans l'intervalle [0.33333ex ; 1ex].

\cleval{notch}{dimension}
Représente la largeur des encoches. La valeur est ramenée si nécessaire dans l'intervalle [0.33333em ; 3em].

\cleval{scale}{coefficient}\label{cle-scale}
Représente l'échelle à laquelle est représenté le dessin. La valeur est ramenée si nécessaire dans l'intervalle [0.2 ; 5].

Les blocs ovales ou losanges, qui peuvent se trouver à l'extérieur de l'environnement scrtach, sont affectés par la valeur de \texttt{scale} :

\exemple/\setscratch{scale=1}Échelle 1 : \ovalvariable{var} et \booloperator{\ovalmove{abscisse x} < \ovalnum{7}}\par
Échelle 0.75 :\setscratch{scale=.75} : \ovalvariable{var} et \booloperator{\ovalmove{abscisse x} < \ovalnum{7}}\par
Échelle 1.25 :\setscratch{scale=1.25} : \ovalvariable{var} et \booloperator{\ovalmove{abscisse x} < \ovalnum{7}}/

\cleval{init arcangle}{angle}
Représente l'angle avec l'horizontale de l'arc de cercle tracé dans la partie haute des blocs de départ. La valeur est ramenée si nécessaire dans l'intervalle [20 ; 40].

\cleval{init arclength}{dimension}
Représente la longueur horizontale de l'arc de cercle tracé dans la partie haute des blocs de départ. La valeur est ramenée si nécessaire dans l'intervalle [3em ; 8em].

\cleval{print}{booléen}
Lorsque ce booléen est vrai, les dessins se font en noir et blanc de façon à pouvoir être dirigés vers une impression en noir et blanc.

\exemple/\begin{scratch}
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch} puis
\begin{scratch}[print]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}/

\cleval{fill blocks}{booléen}
Ce booléen n'est pris en compte que lorsque le booléen \verb|print| est vrai. Si \verb|fill blocks| est vrai, tous les dessins (sauf les ovales contenant des nombres) seront remplis avec un gris choisi avec la clé suivante.

\cleval{fill gray}{taux de gris}
Lorsque \verb|fill blocks| est vrai, ce taux de blanc dans le gris (nombre compris entre 0 pour noir et 1 pour blanc) est utilisé pour définir une couleur de remplissage des dessins. La valeur est ramenée si nécessaire dans l'intervalle [0 ; 1].

\exemple/\begin{scratch}
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch} puis
\begin{scratch}[print,fill blocks]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch} puis
\begin{scratch}[print,fill blocks,fill gray=0.66]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}/

\cleval{contrast}{entier}
Lorsque l'option \verb|print| est vraie, cet entier, compris entre 0 et 100 inclus, qualifie la différence de teinte entre les lignes de relief et la teinte de gris de ces blocs, spécifiée par la clé \texttt{fill gray}. L'entier 0 sélectionne la couleur spécifiée par \texttt{fill gray} tandis que 100 trace les lignes en noir. La valeur est ramenée si nécessaire dans l'intervalle [0 ; 100].

\cleval{text color}{couleur}
Lorsque \verb|fill blocks| est vrai, cette couleur sera utilisée pour le texte des blocs.

\cleval{flag gray}{taux de gris}
Lorsque \verb|print| est vrai, ce taux de gris est utilisé pour la couleur du drapeau tracé avec \verb|\greenflag| ainsi que pour la flèche se trouvant au bas des blocs de répétition. La valeur est ramenée si nécessaire dans l'intervalle [0 ; 1].

\exemple/\begin{scratch}[print,fill blocks,fill gray=0.66]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch} puis
\begin{scratch}[print,fill blocks,fill gray=0.33,text color=white,flag gray=0.66]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}/

\cleval{line gray}{taux de gris}
Lorsque \verb|print| est vrai, ce taux de gris est utilisé pour la couleur des lignes de relief. La valeur est ramenée si nécessaire dans l'intervalle [0 ; 1].

\cleval{num blocks}{booléen}
Lorsque ce booléen est vrai, les blocs sont numérotés.

\cleval{num sep}{dimension}
Cette clé contient l'espacement entre les numéros de blocs et leur frontière gauche. La valeur est ramenée si nécessaire dans l'intervalle [0pt ; 1.5em].

\cleval{num start}{entier}
Cette clé contient le premier numéro du bloc.

La macro \verb|\numblock| est chargée d'imprimer les numéros de ligne. Elle admet un argument (le numéro de ligne) et permet, lorsqu'elle est redéfinie, de personnaliser la numérotation : choix de la couleur, de la police, de sa taille et des effets applicables à son argument. Par défaut, cette macro est définie par
\begin{center}
	\verb|\newcommand*\numblock[1]{\color{black}\footnotesize\bfseries#1}|
\end{center}

Dans l'environnement \SCRATCH, entre des instructions \SCRATCH, on peut activer ou désactiver la numérotation \emph{pour le dessin en cours} à l'aide de
\begin{center}
	\verb|\setscratch{num blocks=<booléen>}|
\end{center}

\exemple/\begin{scratch}[num blocks]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch} puis
\renewcommand*\numblock[1]{\color{blue!80}\itshape#1}
\begin{scratch}[num blocks,num start=3]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}
puis
\renewcommand*\numblock[1]{\fboxsep=0.5pt\fbox{\bfseries#1}}
\begin{scratch}[num blocks=false]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\setscratch{num blocks=true}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}/

\cleval{baseline}{alignement}
Cette clé contient la consigne d'alignement du dessin tout entier, c'est-à-dire :
\begin{itemize}
	\item la lettre «\verb|c|» auquel cas, le dessin est centré sur la ligne de base
	\item un entier qui spécifie un numéro de bloc existant : la numérotation est cohérente avec l'entier initial contenu dans la clé \verb|num start|. Dans ce cas, la ligne de base choisie est celle du texte contenu dans le bloc portant le numéro choisi.
\end{itemize}

\exemple/Défaut : \begin{scratch}
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}
bloc 3 : \begin{scratch}[baseline=3]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}
centré
\begin{scratch}[baseline=c]
	\blockinit{Quand \greenflag est cliqué}
	\blockpen{effacer tout}
	\blocksound{jouer le son \ovalsound*{Meow}}
	\blockmove{ajouter \ovalnum{5} à \ovalvariable{abscisse}}
\end{scratch}/

\section{Mot de la fin}
Le code de cette extension démontre mon immense ignorance de ti\textit kz/pgf et les méthodes de programmation qui lui sont propres que décidément, je ne comprendrai jamais! C'est sans doute le trop grand éloignement avec la logique de \TeX{} et la documentation de ti\textit kz/pgf, aussi indigeste qu'illisible, qui explique cette incompatibilité d'humeur et mon désintérêt à l'égard de ti\textit kz. Toujours est-il que cette extension fonctionne, avec une lenteur certaine que j'attribue autant à ma programmation hasardeuse qu'à la lenteur intrinsèque de ti\textit kz.

Toute remarque, remontée de bug ---~je n'ose pas dire amélioration du code~---, demande d'implémentation de fonctionnalité est bien évidemment bienvenue; j'invite les utilisateurs à m'en faire part \emph{via} email à \texttt{unbonpetit@netc.fr}

\section{Historique}
\begin{version}{0.1}{19/02/2019}
	>Première version.
\end{version}
\begin{version}{0.11}{10/03/2019}
	>Correction d'un bug dans \verb|\scr_blockloop| : la couleur \verb|\scr_current_blockcolor| y est désormais définie;
	>Correction d'un bug dans \verb|\boolmoreblocks| : la couleur est correcte et \verb|rounded corners| désormais est nul pour le tracé d'un losange.
\end{version}
\begin{version}{0.12}{18/05/2019}
	>Correction d'un bug dans \verb|\ovalnum|;
	>Correction d'un bug dans \verb|\scr_ovalbox|.
\end{version}
\begin{version}{0.13}{01/07/2019}
	>Mise en place de \verb|\relax| pour éviter le bug de \verb|\lastkern| avec Xe\LaTeX.
\end{version}
\begin{version}{0.14}{01/10/2019}
	>Gestion de l'échelle (via clé "\texttt{scale}") améliorée.
	>Hors de l'environnement, les ovales et les losanges sont affectés par la clé "\texttt{scale}" si elle est spécifiée via \verb|\setscratch|.
	>Erreur de tracé corrigée dans \verb|\scr_blockloop|.
	>Nouveau losange vide : \verb|\boolempty[<dimension>]|.
\end{version}
\begin{version}{0.15}{05/03/2020}
	>Bug corrigé dans les blocs normaux: l'échelle est désormais réinitialisée si besoin.
\end{version}
\begin{version}{0.16}{20/03/2020}
	>Le bug corrigé dans la v0.15 est fautif, \verb|scr_scale| est désormais initialisée dans \verb|\initmoreblocks|.
\end{version}
\begin{version}{0.17}{27/04/2020}
	>Quelques petites modifications pour ne plus appeler aucune macro privée de simplekv et sa version 0.2.
\end{version}
\end{document}